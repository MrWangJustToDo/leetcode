<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LeetCode题解</title>
    <script src="./List.js"></script>

    <script>
      /*
      501. Find Mode in Binary Search Tree
      For example:
        Given BST [1,null,2,2],

           1
            \
             2
            /
           2


        return [2].
      */
      var findMode = function (root) {
        let map = {};
        let re = [];
        function func(root) {
          if (root) {
            map[root.val]
              ? map[root.val]++
              : (map[root.val] = 1 && re.push(root.val));
            func(root.left);
            func(root.right);
          }
        }
        func(root);
        re.sort((i1, i2) => {
          map[i2] - map[i1];
        });
        for (let i = 1; i < re.length; i++) {
          if (map[re[i]] < map[re[i - 1]]) {
            re = re.slice(0, i);
            break;
          }
        }
        return re;
      };
    </script>

    <script>
      /*
      508. Most Frequent Subtree Sum

      Examples
        Input:

          5
         /  \
        2   -5
        return [2], since 2 happens twice, however -5 only occur once.
        Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.
      */
      var findFrequentTreeSum = function (root) {
        let obj = {};
        let max = 0;
        function func(root) {
          if (root) {
            let val = root.val;
            let left = func(root.left);
            let right = func(root.right);
            let total = val + left + right;
            if (total in obj) {
              obj[total]++;
            } else {
              obj[total] = 1;
            }
            max = Math.max(obj[total], max);
            return total;
          } else {
            return 0;
          }
        }
        func(root);
        let re = [];
        for (let key in obj) {
          if (obj[key] == max) {
            re.push(key);
          }
        }
        return re;
      };
    </script>

    <script>
      /*
      513. Find Bottom Left Tree Value

      Example:
        Input:

                1
               / \
              2   3
             /   / \
            4   5   6
               /
              7

        Output:
        7
      */
      var findBottomLeftValue = function (root) {
        let arr = [root];
        let re = 0;
        while (arr.length) {
          let next = [];
          for (let i = 0; i < arr.length; i++) {
            if (arr[i].left) {
              next.push(arr[i].left);
            }
            if (arr[i].right) {
              next.push(arr[i].right);
            }
          }
          if (!next.length) {
            re = arr[0].val;
          }
          arr = next;
        }
        return re;
      };
    </script>

    <script>
      /*
      515. Find Largest Value in Each Tree Row

      Example:

        Input: root = [1,3,2,5,3,null,9]
        Output: [1,3,9]
      */
      var largestValues = function (root) {
        if (root) {
          let arr = [root];
          let re = [root.val];
          while (arr.length) {
            let next = [];
            for (let i = 0; i < arr.length; i++) {
              if (arr[i].left) {
                next.push(arr[i].left);
              }
              if (arr[i].right) {
                next.push(arr[i].right);
              }
            }
            if (next.length) {
              re.push(Math.max(...next.map((it) => it.val)));
            }
            arr = next;
          }
          return re;
        } else {
          return [];
        }
      };
    </script>

    <script>
      /*
      516. Longest Palindromic Subsequence

      Example:
        Input:
          "bbbab"
        Output:
          4
        One possible longest palindromic subsequence is "bbbb".
      */
      var longestPalindromeSubseq = function (s) {
        // 二维数组的动态规划
        let arr = Array(s.length)
          .fill(0)
          .map((it) => Array(s.length).fill(0));
        let max = 0;
        for (let i = 0; i < s.length; i++) {
          arr[i][i] = 1;
          max = Math.max(max, 1);
          for (let j = i - 1; j >= 0; j--) {
            // 当前范围的最大回文子序列初始为去除最左边的最长回文子序列和去除最右边的最长回文子序列的最大值
            arr[j][i] = Math.max(arr[j + 1][i], arr[j][i - 1]);
            if (s[j] === s[i]) {
              if (i - j == 1) {
                arr[j][i] = 2;
              } else {
                arr[j][i] = 2 + arr[j + 1][i - 1];
              }
              max = Math.max(max, arr[j][i]);
            }
          }
        }
        return max;
      };
    </script>

    <script>
      /*
      518. Coin Change 2

      Example:

        Input: amount = 5, coins = [1, 2, 5]
        Output: 4
        Explanation: there are four ways to make up the amount:
        5=5
        5=2+2+1
        5=2+1+1+1
        5=1+1+1+1+1
      */
      var change = function (amount, coins) {
        let re = Array(coins.length + 1)
          .fill(0)
          .map((it) => Array(amount + 1).fill(0));
        for (let i = 0; i <= coins.length; i++) {
          for (let j = 0; j <= amount; j++) {
            if (j == 0) {
              re[i][j] = 1;
            } else {
              re[i][j] =
                (i - 1 >= 0 ? re[i - 1][j] : 0) +
                (j - coins[i] >= 0 ? re[i][j - coins[i]] : 0);
            }
          }
        }
        return re[coins.length][amount];
      };
    </script>

    <script>
      /*
      520. Detect Capital

      Example:

        Input: "USA"
        Output: True
      */

      var detectCapitalUse = function (word) {
        var flag = true;
        for (var i = 1; i < word.length - 1; i++) {
          if (
            (word[i] >= "a" &&
              word[i] <= "z" &&
              word[i + 1] <= "Z" &&
              word[i + 1] >= "A") ||
            (word[i] >= "A" &&
              word[i] <= "Z" &&
              word[i + 1] <= "z" &&
              word[i + 1] >= "a")
          ) {
            flag = false;
            break;
          }
        }
        if (
          word[0] >= "a" &&
          word[0] <= "z" &&
          word[1] >= "A" &&
          word[1] <= "Z"
        ) {
          flag = false;
        }
        return flag;
      };
    </script>

    <script>
      /*
      521. Longest Uncommon Subsequence I

      Example:

        Input: a = "aba", b = "cdc"
        Output: 3
        Explanation: One longest uncommon subsequence is "aba" because "aba" is a subsequence of "aba" but not "cdc".
        Note that "cdc" is also a longest uncommon subsequence.
      */
      var findLUSlength = function (a, b) {
        if ((a == "" && b == "") || a == b) {
          return -1;
        }
        var max1 = getSubLen(a, b);
        var max2 = getSubLen(b, a);
        return max1 >= max2 ? max1 : max2;
      };

      // 判断a字符串是否是b字符串的子串
      var isSubString = function (a, b) {
        return b.split(a).length == 1;
      };

      // 获取a字符串中不是b字符串子串的最长子串长度
      var getSubLen = function (a, b) {
        var start = 0,
          end = a.length - start;
        while (start < end) {
          for (var i = 0; end + i <= a.length; i++) {
            if (isSubString(a.substring(start + i, end + i), b)) {
              return end - start;
            }
          }
          start++;
          end = a.length - start;
        }
        return -1;
      };
    </script>

    <script>
      /*
      522. Longest Uncommon Subsequence II
      Example:

        Input: "aba", "cdc", "eae"
        Output: 3
      */
      var findLUSlength = function (strs) {
        if (judgeArr(strs)) {
          return -1;
        }
        var max = -1,
          temp;
        for (var i = 0; i < strs.length; i++) {
          temp = getSubSeque(strs[i], i, strs);
          max = max > temp ? max : temp;
        }
        return max;
      };

      var judgeArr = function (strs) {
        var bool1 = true,
          bool2 = true;
        for (var i = 1; i < strs.length; i++) {
          if (strs[i] !== "") {
            bool1 = false;
            break;
          }
        }
        for (var i = 0; i < strs.length - 1; i++) {
          if (strs[i] != strs[i + 1]) {
            bool2 = false;
            break;
          }
        }
        return bool1 || bool2;
      };

      var getSubSeque = function (a, index, b) {
        for (var i = 0; i < b.length; i++) {
          if (i == index) {
            continue;
          }
          if (a == b[i] && i != index) {
            return -1;
          }
          if (isSubSeque(a, b[i])) {
            return -1;
          }
        }
        return a.length;
      };

      // 判断a是否是b的子序列
      var isSubSeque = function (a, b) {
        if (a.length > b.length) {
          return false;
        }
        var temp = 0;
        for (var i = 0; i < a.length; i++) {
          for (var j = temp; j < b.length; j++) {
            if (a[i] == b[j]) {
              temp = j + 1;
              if (temp == b.length && i < a.length - 1) {
                return false;
              }
              break;
            }
            if (j == b.length - 1) {
              return false;
            }
          }
        }
        return true;
      };
    </script>

    <script>
      /*
      523. Continuous Subarray Sum
      Example:

        Input: [23, 2, 6, 4, 7],  k=6
        Output: True
        Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.
      */
      var checkSubarraySum = function (nums, k) {
        for (let i = 0; i < nums.length - 1; i++) {
          let last = nums[i];
          for (let j = i + 1; j < nums.length; j++) {
            last += nums[j];
            if (last == k || last % k == 0) {
              return true;
            }
          }
        }
        return false;
      };
    </script>

    <script>
      /*
      524. Longest Word in Dictionary through Deleting

      Example:
        Input:
        s = "abpcplea", d = ["ale","apple","monkey","plea"]

        Output: 
        "apple"
      */

      // 使用双指针
      var findLongestWord = function (s, d) {
        d.sort((s1, s2) => {
          if (s2.length > s1.length) {
            return 1;
          } else if (s2.length < s1.length) {
            return -1;
          } else {
            if (s2 < s1) {
              return 1;
            } else {
              return -1;
            }
          }
        });
        for (let val of d) {
          if (judge(0, 0, s, val)) {
            return val;
          }
        }
        function judge(i, j, src, tar) {
          if (j === tar.length) {
            return true;
          } else if (j < tar.length) {
            if (i < src.length) {
              while (i < src.length && src[i] != tar[j]) {
                i++;
              }
              if (i == src.length) {
                return false;
              }
              return judge(i + 1, j + 1, src, tar);
            } else {
              return false;
            }
          }
        }
      };
    </script>

    <script>
      /*
      525. Contiguous Array
      Example:

        Input: [0,1,0]
        Output: 2
        Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
      */
      var findMaxLength = function (nums) {
        let map = {};
        let count = 0;
        let max = 0;
        map[0] = -1;
        for (let i = 0; i < nums.length; i++) {
          if (nums[i] == 1) {
            count += 1;
          } else {
            count -= 1;
          }
          if (!(count in map)) {
            map[count] = i;
          } else {
            max = Math.max(max, i - map[count]);
          }
        }
        return max;
      };
    </script>

    <script>
      /*
      526. Beautiful Arrangement

      Example:

        Input: 2
        Output: 2
        Explanation: 

        The first beautiful arrangement is [1, 2]:

        Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).

        Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).

        The second beautiful arrangement is [2, 1]:

        Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).

        Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.
      */
      var countArrangement = function (N) {
        let count = 0;
        let nums = Array(N).fill(0);
        function next(index) {
          if (index == N + 1) {
            count++;
          } else if (index <= N) {
            for (let i = 0; i < nums.length; i++) {
              if (!nums[i] && (index % (i + 1) == 0 || (i + 1) % index == 0)) {
                nums[i] = 1;
                next(index + 1);
                nums[i] = 0;
              }
            }
          }
        }
        next(1);
        return count;
      };
    </script>

    <script>
      /*
      529. Minesweeper

      Example:

        Input: 

        [['E', 'E', 'E', 'E', 'E'],
         ['E', 'E', 'M', 'E', 'E'],
         ['E', 'E', 'E', 'E', 'E'],
         ['E', 'E', 'E', 'E', 'E']]

        Click : [3,0]

        Output: 

        [['B', '1', 'E', '1', 'B'],
         ['B', '1', 'M', '1', 'B'],
         ['B', '1', '1', '1', 'B'],
         ['B', 'B', 'B', 'B', 'B']]

        Explanation:
      */
      var updateBoard = function (board, click) {
        let x = click[0];
        let y = click[1];
        let obj = {};
        if (board[x][y] == "M") {
          board[x][y] = "X";
        } else {
          next(x, y, {});
        }
        function next(row, col, temp) {
          if (
            row >= 0 &&
            col >= 0 &&
            row < board.length &&
            col < board[0].length
          ) {
            temp[row + ":" + col] = 1;
            let key1 = row - 1 + ":" + (col - 1);
            let key2 = row - 1 + ":" + col;
            let key3 = row - 1 + ":" + (col + 1);
            let key4 = row + ":" + (col - 1);
            let key5 = row + ":" + (col + 1);
            let key6 = row + 1 + ":" + (col - 1);
            let key7 = row + 1 + ":" + col;
            let key8 = row + 1 + ":" + (col + 1);
            let arr = Array.of(key1, key2, key3, key4, key5, key6, key7, key8);
            let re = "";
            arr.forEach((it) => {
              let [x, y] = it.split(":");
              re += getRe(Number(x), Number(y));
            });
            if (re.includes("M")) {
              board[row][col] = re.split("M").length - 1 + "";
            } else {
              board[row][col] = "B";
            }
            if (board[row][col] === "B") {
              arr.forEach((it) => {
                if (!(it in temp)) {
                  let [x, y] = it.split(":");
                  next(Number(x), Number(y), temp);
                }
              });
            }
          }
        }
        function getRe(row, col) {
          if (
            row < 0 ||
            col < 0 ||
            row >= board.length ||
            col >= board[0].length
          ) {
            return 0;
          } else {
            return board[row][col];
          }
        }
        return board;
      };
    </script>

    <script>
      /*
      530. Minimum Absolute Difference in BST

      Example:

        Input:

           1
            \
             3
            /
           2

        Output:
        1

        Explanation:
        The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).
      */

      // 中序遍历
      var getMinimumDifference = function (root) {
        let re = [];
        let min = Infinity;
        function func(node, action) {
          if (node) {
            func(node.left, action);
            action(node);
            func(node.right, action);
          }
        }
        func(root, (node) => {
          if (node) {
            re.push(node.val);
            if (re.length > 1) {
              min = Math.min(re[re.length - 1] - re[re.length - 2], min);
            }
          }
        });
        return min;
      };
    </script>

    <script>
      /*
      532. K-diff Pairs in an Array

      Example:

        Input: nums = [3,1,4,1,5], k = 2
        Output: 2
        Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
        Although we have two 1s in the input, we should only return the number of unique pairs.
      */
      var findPairs = function (nums, k) {
        nums.sort((n1, n2) => n1 - n2);
        let obj = {};
        let re = 0;
        for (let i = 0; i < nums.length - 1; i++) {
          if (!(nums[i] in obj)) {
            obj[nums[i]] = 1;
            for (let j = i + 1; j < nums.length; j++) {
              if (nums[j] - nums[i] == k) {
                re++;
                break;
              }
              if (nums[j] - nums[i] > k) {
                break;
              }
            }
          }
        }
        return re;
      };
    </script>

    <script>
      /*
      537. Complex Number Multiplication

      Example:
        Input: "1+1i", "1+1i"
        Output: "0+2i"
        Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.
      */
      var complexNumberMultiply = function (a, b) {
        function Complex(real, imag) {
          this.real = real;
          this.imag = imag;
        }

        Complex.prototype.plus = function (other) {
          return new Complex(this.real + other.real, this.imag + other.imag);
        };

        Complex.prototype.minus = function (other) {
          return new Complex(this.real - other.real, this.imag - other.imag);
        };

        Complex.prototype.multiplication = function (other) {
          return new Complex(
            this.real * other.real - this.imag * other.imag,
            this.imag * other.real + this.real * other.imag
          );
        };

        Complex.prototype.div = function (other) {
          let t = this.multiplication(new Complex(other.real, -other.imag));
          let k = other.multiplication(new Complex(other.real, -other.imag));
          return new Complex(t.real / k.real, t.imag / k.real);
        };
        Complex.prototype.toString = function () {
          return `${this.real}+${this.imag}i`;
        };

        function ctoN(s) {
          let [a, b] = s.split("+");
          b = b.slice(0, -1);
          return [a, b];
        }
        let [x1, y1] = ctoN(a);
        let [x2, y2] = ctoN(b);
        return new Complex(x1, y1)
          .multiplication(new Complex(x2, y2))
          .toString();
      };
    </script>

    <script>
      /*
      538. Convert BST to Greater Tree
      Example:

        Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
        Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
      */
      var convertBST = function (root) {
        let count = 0;
        function next(node, action) {
          if (node) {
            next(node.right, action);
            action(node);
            next(node.left, action);
          }
        }
        next(root, (node) => {
          node.val = node.val + count;
          count = node.val;
        });
        return root;
      };
    </script>

    <script>
      /*
      539. Minimum Time Difference

      Example:
        Input: ["23:59","00:00"]
        Output: 1
      */
      var findMinDifference = function (timePoints) {};
    </script>

    <script>
      /*
      542. 01 Matrix

      Example:

        Input:
        [
          [0,0,0],
          [0,1,0],
          [1,1,1]
        ]

        Output:
        [
          [0,0,0],
          [0,1,0],
          [1,2,1]
        ]
      */

      // 大佬写法
      var updateMatrix = function (matrix) {
        let row = matrix.length;
        let col = matrix[0].length;
        let arr = [];
        for (let i = 0; i < row; i++) {
          for (let j = 0; j < col; j++) {
            if (matrix[i][j] === 0) {
              arr.push([i, j]);
            } else {
              matrix[i][j] = Infinity;
            }
          }
        }
        while (arr.length) {
          let [x, y] = arr.pop();
          for (let i = x - 1; i <= x + 1; i++) {
            for (let j = y - 1; j <= y + 1; j++) {
              if (i >= 0 && i < row && j >= 0 && j < col) {
                if (x == i || y == j) {
                  if (matrix[i][j] > matrix[x][y] + 1) {
                    matrix[i][j] = matrix[x][y] + 1;
                    arr.push([i, j]);
                  }
                }
              }
            }
          }
        }
        console.log(matrix);
      };
    </script>

    <script>
      /*
      543. Diameter of Binary Tree

      Example:
        Given a binary tree
                  1
                / \
                2   3
              / \     
              4   5    
        Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
      */
      var diameterOfBinaryTree = function (root) {
        let max = 0;
        function getMax(node) {
          if (node) {
            let maxLeft = getMax(node.left);
            let maxRight = getMax(node.right);
            max = Math.max(max, maxLeft + maxRight);
            return 1 + Math.max(maxLeft, maxRight);
          } else {
            return 0;
          }
        }
        getMax(root);
        return max;
      };
    </script>

    <script>
      /*
      546. Remove Boxes
      Example:

        Input: boxes = [1,3,2,2,2,3,4,3,1]
        Output: 23
        Explanation:
        [1, 3, 2, 2, 2, 3, 4, 3, 1]
        ----> [1, 3, 3, 4, 3, 1] (3*3=9 points)
        ----> [1, 3, 3, 3, 1] (1*1=1 points)
        ----> [1, 1] (3*3=9 points)
        ----> [] (2*2=4 points)
      */
      var removeBoxes = function (boxes) {
        let obj = {};
        function get(arr) {
          if (arr.length === 1) {
            return 1;
          }
          if (arr.length === 0) {
            return 0;
          }
          let key = arr.join("");
          if (key in obj) {
            return +obj[key];
          }
          // 第一步  移除所有的单个
          let temp = {};
          let start = 0;
          let end = 0;
          while (end < arr.length) {
            if (arr[start] !== arr[end]) {
            }
          }
        }
      };
      // console.log(removeBoxes([1, 3, 2, 2, 2, 3, 4, 3, 1]));
    </script>

    <script>
      /*
      547. Number of Provinces
      Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
      Output: 3

      深搜题目   和之前遇到的其他的类似
      每一层就是当前这个位置和其他位置是否是朋友关系
      */
      var findCircleNum = function (isConnected) {
        let arr = Array(isConnected.length).fill(false);
        let re = 0;
        const dfs = (row) => {
          row.forEach((it, i) => {
            if (!arr[i] && it) {
              arr[i] = true;
              dfs(isConnected[i]);
            }
          });
        };
        arr.forEach((it, i) => {
          // 当前位置还是孤立的  从当前位置开始  进行深搜  标记出所有的朋友节点
          if (!it) {
            re++;
            arr[i] = true;
            dfs(isConnected[i]);
          }
        });
        return re;
      };
    </script>

    <script>
      /*
      551. Student Attendance Record I
      Example:
        Input: "PPALLP"
        Output: True
      Example:
        Input: "PPALLL"
        Output: False
      */
      var checkRecord = function (s) {
        const arr = s.split("");
        return (
          s.split("").filter((it) => it === "A").length < 2 &&
          s.plit("LLL").length === 1
        );
      };
    </script>

    <script>
      /*
      552. Student Attendance Record II
      Example:
        Input: n = 2
        Output: 8 
        Explanation:
        There are 8 records with length 2 will be regarded as rewardable:
        "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"
        Only "AA" won't be regarded as rewardable owing to more than one absent times.
      */
      // 动态规划
      /*
      A 最多一个
      LLL 不能连续三个
      P 任意
      1:  A L P
      2:  AL AP LA LL LP PA PL PP
      3:  ALL 
      */
      var checkRecord = function (n) {};
    </script>

    <script>
      /*
      553. Optimal Division
      Example:
        Input: nums = [1000,100,10,2]
        Output: "1000/(100/10/2)"
        Explanation:
        1000/(100/10/2) = 1000/((100/10)/2) = 200
        However, the bold parenthesis in "1000/((100/10)/2)" are redundant, since they don't influence the operation priority. So you should return "1000/(100/10/2)".
        Other cases:
        1000/(100/10)/2 = 50
        1000/(100/(10/2)) = 50
        1000/100/10/2 = 0.5
        1000/100/(10/2) = 2
      */
      var optimalDivision = function (nums) {
        if (nums.length > 2) {
          return nums.slice(0, 1) + "/(" + nums.slice(1).join("/") + ")";
        } else if (nums.length > 1) {
          return nums.join("/");
        } else {
          return String(nums[0]);
        }
      };
    </script>

    <script>
      /*
      554. Brick Wall

      Input: wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
      Output: 2
      */
      var leastBricks = function (wall) {
        let re = {};
        let max = "";
        const newWall = wall.map((it) => {
          let temp = 0;
          for (let i = 0; i < it.length - 1; i++) {
            temp += it[i];
            re[temp] = re[temp] ? re[temp] + 1 : 1;
            max = re[max] > re[temp] ? max : temp;
          }
        });
        return wall.length - (re[max] ? re[max] : 0);
      };
      console.log(leastBricks([[1], [1], [1]]));
    </script>

    <script>
      /*
      556. Next Greater Element III
      Example:

        Input: n = 12
        Output: 21
      */
      var nextGreaterElement = function (n) {
        let arr = String(n).split("");
        let point;
        // 判断当前数字的排序  如果是完全降序  则不存在结果
        for (let i = arr.length - 1; i >= 1; i--) {
          if (arr[i] > arr[i - 1]) {
            point = i - 1;
            break;
          }
        }
        if (point !== undefined) {
          let min;
          for (let i = arr.length - 1; i > point; i--) {
            if (arr[i] > arr[point]) {
              if (!min) {
                min = i;
              } else {
                min = arr[min] > arr[i] ? i : min;
              }
            }
          }
          run(min, point, arr);
          const re = Number(
            arr
              .slice(0, point)
              .concat(
                arr[point],
                arr.slice(point + 1).sort((a, b) => (a > b ? 1 : -1))
              )
              .join("")
          );
          return re > 2147483647 ? -1 : re;
        } else {
          return -1;
        }
        function run(i, j, arr) {
          let temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;
        }
      };
    </script>

    <script>
      /*
      560. Subarray Sum Equals K

      Example:

        Input: nums = [1,2,3], k = 3
        Output: 2
      */
      // 超出限制...
      var subarraySum = function (nums, k) {
        let re = 0;
        let obj = {};
        nums.forEach((item, index) => {
          for (let key in obj) {
            if (obj[key] != k) {
              obj[key] += item;
              if (obj[key] == k) {
                re++;
              }
            }
          }
          obj[index] = item;
        });
        return re;
      };
      // 使用hash
      var subarraySum = function (nums, k) {
        let re = 0;
        let obj = {};
        obj[0] = 1;
        let sum = 0;
        for (let item of nums) {
          sum += item;
          obj[sum] = obj[sum] || 0;

          re += Number(obj[sum - k] || 0);
          obj[sum]++;
        }
        console.log(obj);
        console.log(re);
        return re;
      };
      // subarraySum([1, 1, 1], 2);
    </script>

    <script>
      /*
      563. Binary Tree Tilt

      Input: root = [4,2,9,3,5,null,7]
      Output: 15
      Explanation: 
      Tilt of node 3 : |0-0| = 0 (no children)
      Tilt of node 5 : |0-0| = 0 (no children)
      Tilt of node 7 : |0-0| = 0 (no children)
      Tilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)
      Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)
      Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)
      Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15
      */
      var findTilt = function (root) {
        let count = 0;
        function get(node) {
          if (node) {
            let leftChild = get(node.left);
            let rightChild = get(node.right);
            count += Math.abs(leftChild - rightChild);
            return node.val + leftChild + rightChild;
          } else {
            return 0;
          }
        }
        get(root);
        return count;
      };
    </script>

    <script>
      /*
      564. Find the Closest Palindrome
      找到绝对值差最小的回文数
      Example:
        Input: "123"
        Output: "121"
      */
      var nearestPalindromic = function (n) {
        if (n <= 10) {
          return n - 1 + "";
        }
        function get(num) {
          if (num.length % 2 === 0) {
          }
        }
      };
    </script>

    <script>
      /*
      565. Array Nesting

      Example:

        Input: A = [5,4,0,3,1,6,2]
        Output: 4
        Explanation: 
        A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

        One of the longest S[K]:
        S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
      */
      var arrayNesting = function (nums) {
        const array = Array(nums.length);
        let re = 0;
        // 每选择了一个新的索引数字，后续的结果就都是确定的
        // 所以应该在每次遇到一个新的数字的时候进行记录
        function run(entryIndex, arr, temp, count) {
          // 入口起点
          // 当前目标 --> 下一个目标
          count++;
          // 记录每一步的索引
          temp.push(entryIndex);
          const nextIndex = nums[entryIndex];
          if (arr.includes(nextIndex) || array[nextIndex]) {
            let last = array[nextIndex];
            // 下一个目标已经是记录过的
            if (last) {
              re = Math.max(re, count + last);
            } else {
              re = Math.max(re, count);
            }
            // 往回填充遇到的索引
            let res = last || 1;
            for (let i = temp.length - 1; i >= 0; i--) {
              array[temp[i]] = res++;
            }
          } else {
            arr.push(nextIndex);
            // 下一个目标没有记录过
            run(nextIndex, arr, temp, count);
          }
        }
        for (let i = 0; i < nums.length; i++) {
          if (!array[i]) {
            let arr = [];
            arr.push(nums[i]);
            run(nums[i], arr, [], 0);
          }
        }
        return re;
      };

      // arrayNesting([5, 4, 0, 3, 1, 6, 2]);
    </script>

    <script>
      /*
      566. Reshape the Matrix
      Example:
        Input: 
        nums = 
        [
          [1,2],
          [3,4]
        ]
        r = 1, c = 4
        Output: 
        [[1,2,3,4]]
        Explanation:
        The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.
      */

      var matrixReshape = function (nums, r, c) {
        if (nums.length * nums[0].length === r * c) {
          let x = 0,
            y = 0;
          return Array(r)
            .fill(0)
            .map((it) =>
              Array(c)
                .fill(0)
                .map((item) => {
                  if (x < nums.length && y < nums[0].length) {
                    return nums[x][y++];
                  } else if (y === nums[0].length) {
                    x++;
                    y = 0;
                    return nums[x][y++];
                  }
                })
            );
        } else {
          return nums;
        }
      };
    </script>

    <script>
      /*
      567. Permutation in String
      Example:

        Input: s1 = "ab" s2 = "eidbaooo"
        Output: True
        Explanation: s2 contains one permutation of s1 ("ba").
      */
      // 滑动窗口
      var checkInclusion = function (s1, s2) {
        if (s2.length < s1.length) {
          return false;
        }
        let obj = {};
        Array.from(s1).forEach((it) => {
          if (it in obj) {
            obj[it]++;
          } else {
            obj[it] = 1;
          }
        });
        let length = s1.length;
        let left = 0;
        let right = 0;
        while (right < s2.length) {
          if (s2[right] in obj) {
            if (obj[s2[right]] > 0) {
              obj[s2[right]]--;
              length--;
            } else {
              while (s2[left] != s2[right]) {
                if (s2[left] in obj) {
                  obj[s2[left]]++;
                  length++;
                }
                left++;
              }
              left++;
            }
          }
          while (length === 0) {
            if (right - left === s1.length - 1) {
              return true;
            } else {
              if (s2[left] in obj) {
                obj[s2[left]]++;
                length++;
              }
              left++;
            }
          }
          right++;
        }
        return false;
      };
    </script>

    <script>
      /*
      572. Subtree of Another Tree

      Example:
        Given tree s:
            
            3
            / \
          4   5
          / \
        1   2
        Given tree t:
          4 
          / \
        1   2
        Return true, because t has the same structure and node values with a subtree of s.
      */
      var isSubtree = function (s, t) {
        let re = false;
        function judgeTree(tr1, tr2) {
          if (!tr1 && !tr2) {
            return true;
          } else if (tr1 && tr2) {
            if (tr1.val === tr2.val) {
              return (
                judgeTree(tr1.left, tr2.left) && judgeTree(tr1.right, tr2.right)
              );
            } else {
              return false;
            }
          } else {
            return false;
          }
        }
        function run(node) {
          if (node) {
            if (node.val === t.val) {
              re = re || judgeTree(node, t);
            }
            if (!re) {
              run(node.left);
            }
            if (!re) {
              run(node.right);
            }
          }
        }
        run(s);
        return re;
      };
    </script>

    <script>
      /*
      575. Distribute Candies

      Example:

        Input: candyType = [1,1,2,3]
        Output: 2
        Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.
      */
      var distributeCandies = function (candies) {
        if (candies.length == 2) {
          return 1;
        }
        let obj = {};
        let len = candies.length / 2;
        let temp = 0;
        for (var i = 0; i < candies.length; i++) {
          if (!(candies[i] in obj)) {
            obj[candies[i]] = 1;
            temp++;
          }
        }
        return len > temp ? temp : len;
      };
    </script>

    <script>
      /*
      576. Out of Boundary Paths

      Example:

        Input: m = 2, n = 2, N = 2, i = 0, j = 0
        Output: 6
      */
      // 应该会有两种解决办法：记忆数组以及动态规划

      // 记忆数组
      var findPaths = function (m, n, N, i, j) {
        let obj = {};
        function run(x, y, count, last) {
          let key = x + ":" + y + ":" + count + ":" + last;
          if (key in obj) {
            return obj[key];
          }
          let all = 0;
          if (last >= 0) {
            if (x < 0 || y < 0 || x >= m || y >= n) {
              return 1;
            }
            all += run(x - 1, y, count + 1, last - 1);
            all += run(x + 1, y, count + 1, last - 1);
            all += run(x, y - 1, count + 1, last - 1);
            all += run(x, y + 1, count + 1, last - 1);
            all = all % (Math.pow(10, 9) + 7);
            obj[key] = all;
            return all;
          } else {
            return 0;
          }
        }
        console.log(run(i, j, 0, N));
        return run(i, j, 0, N) % (Math.pow(10, 9) + 7);
      };
      // findPaths(2, 2, 2, 0, 0);
    </script>

    <script>
      /*
      581. Shortest Unsorted Continuous Subarray

      Example:

        Input: nums = [2,6,4,8,10,9,15]
        Output: 5
        Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
      */
      var findUnsortedSubarray = function (nums) {
        // 只需要排序后在和原来比较一下?
        const newArr = Array.from(nums);
        newArr.sort((a, b) => (a > b ? 1 : -1));
        let start, end;
        nums.forEach((item, index) => {
          if (item !== newArr[index]) {
            if (start === undefined) {
              start = index;
            } else {
              end = index;
            }
          }
        });
        if (start === undefined) {
          return 0;
        }
        return end - start + 1;
      };
      // 0(n)时间复杂度完成
    </script>

    <script>
      /*
      583. Delete Operation for Two Strings

      两个字符串的最长相等子序列
      Example:
        Input: "sea", "eat"
        Output: 2
        Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
      */
      var minDistance = function (word1, word2) {
        /*
        word1 i   word2 j  最长子序列
        如果相等  = 1 + word1 i-1  word j-1 加上错位比较
        如果不等  = max(word1 i   word2 j-1,  word i-1   word2 j)
        */

        // 使用dp
        if (word1 === word2) {
          return 0;
        }
        const arr = Array(word1.length)
          .fill(0)
          .map((it) => Array(word2.length));
        let max = 0;
        for (let i = 0; i < word1.length; i++) {
          for (let j = 0; j < word2.length; j++) {
            if (word1[i] === word2[j]) {
              arr[i][j] = Math.max(
                j > 0 ? arr[i][j - 1] : 0,
                i > 0 ? arr[i - 1][j] : 0,
                1 + (i > 0 && j > 0 ? arr[i - 1][j - 1] : 0)
              );
            } else {
              arr[i][j] = Math.max(
                j > 0 ? arr[i][j - 1] : 0,
                i > 0 ? arr[i - 1][j] : 0
              );
            }
            max = Math.max(max, arr[i][j]);
          }
        }
        return word1.length - max + word2.length - max;
      };
      // console.log(minDistance("uon", "un"));
    </script>

    <script>
      /*
      589. N-ary Tree Preorder Traversal
      多叉数的先序遍历
      Input: 
        root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
      Output: 
        [1,2,3,6,7,11,14,4,8,12,5,9,13,10]
      */
      // 递归实现
      var preorder = function (root) {
        function loop(node, arr = []) {
          if (node) {
            arr.push(node.val);
            let children = node.children;
            children.forEach((c_node) => loop(c_node, arr));
          }
        }
        const re = [];
        loop(root, re);
        return re;
      };
      // 迭代实现
      var preorder = function (root) {
        const re = [];
        if (root) {
          let arr = [root];
          while (arr.length) {
            let last = arr.pop();
            re.push(last.val);
            if (last.children) {
              arr = arr.concat(last.children.reverse());
            }
          }
        }
        return re;
      };
    </script>

    <script>
      /*
      590. N-ary Tree Postorder Traversal
      多叉数的后序遍历
      Input: 
        root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
      Output: 
        [2,6,14,11,7,3,12,8,4,13,9,10,5,1]
      */
      // 递归实现
      var postorder = function (root) {
        function loop(node, arr) {
          if (node) {
            if (node.children) {
              let children = node.children;
              children.forEach((c_node) => loop(c_node, arr));
            }
            arr.push(node.val);
          }
        }
        const re = [];
        loop(root, re);
        return re;
      };
      // 迭代实现
      var postorder = function (root) {};
    </script>

    <script>
      /*
      592. Fraction Addition and Subtraction

      // 字符串分数运算

      Example:
        Input:"5/3+1/3"
        Output: "2/1"
      */
      var fractionAddition = function (expression) {
        if (expression[0] !== "-") {
          expression = "+" + expression;
        }
        let re = "0/1";
        let temp = "";
        let start = 0;
        let count = 0;
        function add(ex1, ex2) {
          let arr1 = ex1.split("/");
          let arr2 = ex2.split("/");
          if (arr1[1] === arr2[1]) {
            return Number(arr1[0]) + Number(arr2[0]) + "/" + arr1[1];
          } else {
            return (
              Number(arr1[0]) * Number(arr2[1]) +
              Number(arr2[0]) * Number(arr1[1]) +
              "/" +
              Number(arr1[1]) * Number(arr2[1])
            );
          }
        }
        function gcb(num1, num2) {
          if (num2 === 0) return num1;
          return gcb(num2, num1 % num2);
        }
        while (start < expression.length) {
          if ((expression[start] === "-") | (expression[start] === "+")) {
            if (count === 0) {
              count++;
              temp += expression[start++];
            } else {
              count = 0;
              // console.log(re, temp);
              re = add(re, temp);
              temp = "";
            }
          } else {
            temp += expression[start++];
          }
        }
        re = add(re, temp);
        let arr = re.split("/");
        if (arr[0] === "0") {
          return "0/1";
        }
        if (arr[0] % arr[1] === 0) {
          return arr[0] / arr[1] + "/1";
        }
        let b = gcb(arr[0], arr[1]);
        return arr.map((it) => it / Math.abs(b)).join("/");
      };

      // console.log(fractionAddition("82/24"))
    </script>

    <script>
      /*
      593. Valid Square

      // 有效正方形

      Example:

        Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]
        Output: true
      */
      var validSquare = function (p1, p2, p3, p4) {
        const arr = [p1, p2, p3, p4];
        // 获取两点之间的距离
        const getLength = (p1, p2) => {
          return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);
        };
        const obj = {};
        for (let i = 0; i < arr.length - 1; i++) {
          for (let j = i + 1; j < arr.length; j++) {
            const temp = getLength(arr[i], arr[j]);
            if (temp === 0) {
              return false;
            }
            obj[temp] = 1;
          }
        }
        if (Object.keys(obj).length === 2) {
          return true;
        }
        return false;
      };
    </script>

    <script>
      /*
      594. Longest Harmonious Subsequence

      Example:

        Input: nums = [1,3,2,2,5,2,3,7]
        Output: 5
        Explanation: The longest harmonious subsequence is [3,2,2,2,3].
      */
      var findLHS = function (nums) {
        // 使用对象
        let obj = {};
        nums.forEach((it) => {
          if (it in obj) {
            obj[it]++;
          } else {
            obj[it] = 1;
          }
        });
        let max = 0;
        for (let key in obj) {
          if (+key + 1 in obj) {
            max = Math.max(max, obj[key] + obj[+key + 1]);
          }
        }
        return max;
      };
    </script>

    <script>
      /*
      598. Range Addition II
      
      Input: m = 3, n = 3, ops = [[2,2],[3,3]]
      Output: 4
      Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.
      */
      var maxCount = function (m, n, ops) {
        let max = [m, n];
        ops.forEach((it) => {
          let [x, y] = it;
          if (x < max[0] && x > 0) {
            max[0] = x;
          }
          if (y < max[1] && y > 0) {
            max[1] = y;
          }
        });
        return max[0] * max[1];
      };
    </script>

    <script>
      /*
      599. Minimum Index Sum of Two Lists

      Example:

        Input: list1 = ["Shogun","Tapioca Express","Burger King","KFC"], list2 = ["Piatti","The Grill at Torrey Pines","Hungry Hunter Steakhouse","Shogun"]
        Output: ["Shogun"]
        Explanation: The only restaurant they both like is "Shogun".
      */
      var findRestaurant = function (list1, list2) {
        let obj = {};
        let temp = {};
        let min = Infinity;
        let re = [];
        list1.forEach((it, i) => {
          temp[it] = i;
        });
        list2.forEach((it, i) => {
          if (it in temp) {
            obj[it] = temp[it] + i;
            min = Math.min(min, obj[it]);
          }
        });
        for (let key in obj) {
          if (obj[key] === min) {
            re.push(key);
          }
        }
        return re;
      };
    </script>
  </head>
  <body></body>
</html>
